# 暑期算法训练报告

---

<img src="img\cug.png" alt="cug" style="zoom:33%;" />

**班级：11J192**

**姓名：刘原**

**学号：20191002406**

**指导教师：张剑波**

---

## 链表

### 1. 翻转链表

> #### 通过截图
>
> ![1](img\1.png)
>
> #### 算法思路
>
> 维护`prev, this, next`三个指针，然后做如下交换：
>
> ``` c++
> prev = this;
> this = next;
> next = next->next;
> this->next = prev;
> ```
>
> 

### 2. 链表划分

> #### 通过截图
>
> ![2](img\2.png)
>
> 
>
> #### 算法思路
>
> 维护两个链表`a, b`分别存储小于x和大于等于`x`的节点，然后直接合并。

### 3. 删除链表中的重复元素

> #### 通过截图
>
> ![image-20200816012736096](C:\Users\ly\Documents\src\algoexec\src\11J192\刘原\algorithm report\img\3.png)
>
> #### 算法思路
> 
>判断当前节点与下一节点是否相同，如相同就删除下一节点。

### 4. 合并两个排序链表

> #### 通过截图
>
> ![4](img\4.png)
>
> #### 算法思路
> 
>相同于归并排序的合并操作。

### 5. 链表倒数第n个节点

> #### 通过截图
>
> ![5](img\5.png)
>
> #### 算法思路
> 
>维护`a, b`两个指针，使`a, b`相差n-1个节点，这样`a`到链表末时，`b`就为倒数第n个节点。

### 6. 链表插入排序

> #### 通过截图
>
> ![6](img\6.png)
>
> #### 算法思路
> 
>使用插入排序需要新建一个链表，效率低下，故使用快速排序。

### 7. 删除链表中第n个节点

> #### 通过截图
>
> ![7](img\7.png)
>
> #### 算法思路
> 
>同5。

### 8. 在排序链表中插入一个节点

> #### 通过截图
>
> ![8](img\8.png)
>
> #### 算法思路
> 
>标准的Linked list的INSERT操作。

### 9. 两两交换链表中的节点

> #### 通过截图
>
> ![9](img\9.png)
>
> #### 算法思路
>
> 维护`a, b, c, d`四个指针，每次进行如下交换：
>
> ``` c++
> a->next = c;
> c->next = b;
> b->next = d;
> ```
>
> 

### 10. 删除链表中的元素

> #### 通过截图
>
> ![10](img\10.png)
>
> #### 算法思路
> 
>查找每一个节点的值是否等于`val`并删除对应节点。

### 11. 队列维护

> #### 通过截图
>
> ![11](img\11.png)
>
> #### 算法思路
>
> 1. 使用链表
>
>    ``` c++
>    class ListNode
>    {
>    public:
>        int val;
>        ListNode *next;
>        ListNode(int val) {
>           this->val = val;
>           this->next = NULL;
>        }
>    };
>    
>    class MyQueue
>    {
>    public:
>        void enqueue(int item)
>        {
>            if (t == nullptr)
>            {
>                h = t = new ListNode {item, nullptr};
>            }
>            else
>            {
>                t->next = new ListNode {item, nullptr};
>                t = t->next;
>    		}
>    	}
>        
>        int dequeue()
>        {
>            int ret = h->val;
>            h = h->next;
>            if (h == nullptr)
>                t = nullptr;
>    	}
>    private:
>        ListNode* h = nullptr;
>        ListNode* t = nullptr;
>    }
>    ```
>
>    
>
> 2. 使用`std::queue<int>`.

### 12. 两数相乘

> #### 通过截图
>
> ![12](img\12.png)
>
> #### 算法思路
> 
>使用两个`long long`保存两个数，并输出乘积。

## 数组

### 1. 二分查找

> #### 通过截图
>
> ![1](img\13.png)
>
> #### 算法思路
> 
>查找第一个大于等于`target`的元素，然后判断是否等于`target`.

### 2. 恢复旋转排序数组

> #### 通过截图
>
> ![2](img\14.png)
>
> #### 算法思路
>
> 首先遍历数组，找到旋转点k，然后进行3次旋转操作：
>
> ``` pseudocode
> rotate[0, k];
> rotate[k + 1, n - 1];
> rotate[0, n - 1];
> ```

### 3. 两数之和

> #### 通过截图
>
>![3](img\15.png)
>
> #### 算法思路
> 
>使用`std::map<int, int>`来保存每个数字的位置，然后对数组里面的每一个数字进行查询。

### 4. 

> #### 通过截图
>
>![4](img\16.png)
>
> #### 算法思路
> 
>同1.

### 5. 删除排序数组中的重复数字

> #### 通过截图
>
> ![5](img\17.png)
>
> #### 算法思路
>
> 1. 使用`std::unique`.
> 2. 每当`nums[i] == nums[i + 1]`时删除当前元素。

### 6. 删除排序数组中的重复数字 II

> #### 通过截图
>
>![6](img\18.png)
>
> #### 算法思路
> 
>使用`n`记录当前数字出现了几次，其他同5.

### 7. 不同的路径 II

> #### 通过截图
>
> ![7](img\19.png)
>
> #### 算法思路
>
> BFS
>
> ``` c++
> n[i][j] = n[i - 1][j] + n[i][j - 1];
> ```

### 8. 合并区间

> #### 通过截图
>
>![8](img\20.png)
>
> #### 算法思路
> 
>首先对区间按照`start`进行排序，然后逐一合并重叠部分。

### 9. 删除元素

> #### 通过截图
>
>![9](img\21.png)
>
> #### 算法思路
> 
>直接删除。

### 10. 最近的城市

> #### 通过截图
>
> ![10](img\22.png)
>
> #### 算法思路
>
> 首先确定查询的城市的下标，然后搜索同行或者同列，距离最短，字母序最小的城市。
>

### 11. 最长上升连续子序列

> #### 通过截图
>
>![11](img\23.png)
>
> #### 算法思路
> 
>分别查找正向和逆向的最长连续上升子序列，然后输出其中更长的。

### 12. 加一

> #### 通过截图
>
>![12](img\24.png)
>
> #### 算法思路
> 
>把加一当作下一位的进位，然后就维护一个进位就可以了。
